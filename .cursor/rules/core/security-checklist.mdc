---
description: Security best practices for authentication, authorization, and data handling
globs: ["app/**/*.ts", "app/**/*.tsx", "actions/**/*.ts", "lib/**/*.ts"]
alwaysApply: true
---

# Security Checklist

## Authentication

### ✅ Always Use `getUser()` Not `getSession()`

```typescript
// ❌ WRONG - getSession() can be spoofed
const { data: { session } } = await supabase.auth.getSession();
if (session) { /* UNSAFE */ }

// ✅ CORRECT - getUser() validates with the server
const { data: { user } } = await supabase.auth.getUser();
if (user) { /* Safe - verified with Supabase */ }
```

**Why:** `getSession()` reads from cookies without server validation. A malicious user can forge session cookies. `getUser()` makes a request to Supabase to verify the JWT.

### ✅ Check Auth in Every Server Action

```typescript
'use server';

export async function deletePost(postId: string) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  
  // Always check auth FIRST
  if (!user) {
    return { error: 'Unauthorized' };
  }
  
  // Then check authorization (ownership)
  const { data: post } = await supabase
    .from('posts')
    .select('user_id')
    .eq('id', postId)
    .single();
    
  if (post?.user_id !== user.id) {
    return { error: 'Forbidden' };
  }
  
  // Now safe to delete
  await supabase.from('posts').delete().eq('id', postId);
}
```

---

## Input Validation

### ✅ Always Validate with Zod

```typescript
import { z } from 'zod';

const CreatePostSchema = z.object({
  title: z.string().min(1, 'Title required').max(100),
  content: z.string().min(10, 'Content too short').max(10000),
  published: z.boolean().default(false),
});

export async function createPost(formData: FormData) {
  const parsed = CreatePostSchema.safeParse({
    title: formData.get('title'),
    content: formData.get('content'),
    published: formData.get('published') === 'true',
  });
  
  if (!parsed.success) {
    return { error: parsed.error.issues[0].message };
  }
  
  // Use parsed.data - it's validated and typed
  const { title, content, published } = parsed.data;
}
```

### ✅ Never Trust Client Data

```typescript
// ❌ WRONG - trusting client-sent user ID
export async function updateProfile(formData: FormData) {
  const userId = formData.get('userId'); // Client can send any ID!
  await db.update(userId, { name: formData.get('name') });
}

// ✅ CORRECT - get user ID from authenticated session
export async function updateProfile(formData: FormData) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();
  
  if (!user) return { error: 'Unauthorized' };
  
  await supabase
    .from('profiles')
    .update({ name: formData.get('name') })
    .eq('id', user.id); // Use verified user ID
}
```

---

## Secrets Management

### ✅ Environment Variable Rules

| Prefix | Exposure | Use For |
|--------|----------|---------|
| `NEXT_PUBLIC_` | Browser + Server | Public URLs, publishable keys |
| No prefix | Server only | API keys, secrets, DB URLs |

```bash
# .env.local (gitignored)
NEXT_PUBLIC_SUPABASE_URL=https://xxx.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJ...  # Public, safe

SUPABASE_SERVICE_ROLE_KEY=eyJ...      # SECRET - never expose
OPENAI_API_KEY=sk-...                 # SECRET - never expose
```

### ✅ Never Hardcode Secrets

```typescript
// ❌ NEVER do this
const apiKey = 'sk-1234567890abcdef';

// ✅ Always use environment variables
const apiKey = process.env.OPENAI_API_KEY;

if (!apiKey) {
  throw new Error('Missing OPENAI_API_KEY');
}
```

### ✅ Never Log Sensitive Data

```typescript
// ❌ WRONG
console.log('User data:', { email, password, token });

// ✅ CORRECT - log only non-sensitive identifiers
console.log('User action:', { userId: user.id, action: 'login' });
```

---

## Database Security

### ✅ Always Enable RLS

```sql
-- Every table needs this
alter table public.posts enable row level security;

-- Then add appropriate policies
create policy "Users can read own posts"
  on public.posts for select
  to authenticated
  using ((select auth.uid()) = user_id);
```

### ✅ Use Parameterized Queries

Supabase client handles this automatically, but if using raw SQL:

```typescript
// ❌ WRONG - SQL injection risk
const { data } = await supabase.rpc('search', {
  query: `SELECT * FROM posts WHERE title = '${userInput}'`
});

// ✅ CORRECT - parameterized
const { data } = await supabase
  .from('posts')
  .select('*')
  .eq('title', userInput);
```

---

## API Security

### ✅ Rate Limit Public Endpoints

```typescript
// For API routes that are publicly accessible
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, '10 s'), // 10 requests per 10 seconds
});

export async function POST(request: Request) {
  const ip = request.headers.get('x-forwarded-for') ?? '127.0.0.1';
  const { success } = await ratelimit.limit(ip);
  
  if (!success) {
    return Response.json({ error: 'Too many requests' }, { status: 429 });
  }
  
  // Process request
}
```

### ✅ Validate Webhook Signatures

```typescript
// app/api/webhooks/stripe/route.ts
import Stripe from 'stripe';

export async function POST(request: Request) {
  const body = await request.text();
  const signature = request.headers.get('stripe-signature')!;
  
  try {
    const event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
    // Process verified event
  } catch (err) {
    return Response.json({ error: 'Invalid signature' }, { status: 400 });
  }
}
```

---

## Error Handling

### ✅ Never Expose Internal Errors

```typescript
// ❌ WRONG - exposes database details
catch (error) {
  return { error: error.message }; // "duplicate key value violates unique constraint"
}

// ✅ CORRECT - user-friendly message
const ERROR_MESSAGES: Record<string, string> = {
  '23505': 'This item already exists',
  '23503': 'Referenced item not found',
};

catch (error) {
  console.error('Database error:', error); // Log internally
  
  const code = error?.code;
  const message = ERROR_MESSAGES[code] || 'Something went wrong';
  return { error: message }; // Return safe message
}
```

---

## Quick Checklist

Before deploying, verify:

- [ ] All Server Actions check `getUser()` before mutations
- [ ] All user input validated with Zod schemas
- [ ] No `NEXT_PUBLIC_` prefix on secret keys
- [ ] No hardcoded API keys or secrets
- [ ] No `console.log` with sensitive data
- [ ] RLS enabled on all Supabase tables
- [ ] Webhook endpoints validate signatures
- [ ] Error messages don't expose internals

---
description: Test-driven development workflow and testing patterns
globs: ["**/*.test.ts", "**/*.test.tsx", "**/*.spec.ts", "tests/**/*", "e2e/**/*"]
---

# Test-Driven Development Workflow

## TDD Cycle

```
1. RED    → Write a failing test
2. GREEN  → Write minimal code to pass
3. REFACTOR → Clean up, keep tests passing
```

## When to Write Tests

| Situation | Test First? |
|-----------|-------------|
| New feature | Yes - define behavior first |
| Bug fix | Yes - reproduce bug in test first |
| Refactoring | Tests should already exist |
| Prototype/spike | No - delete and rewrite with tests |

## Testing Stack for This Project

```bash
# Unit tests
npm install -D vitest @testing-library/react @testing-library/dom jsdom

# E2E tests
npm install -D @playwright/test
```

## Unit Testing Patterns

### Testing React Components

```typescript
// components/button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './button';

describe('Button', () => {
  it('renders children', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('calls onClick when clicked', () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click</Button>);
    
    fireEvent.click(screen.getByRole('button'));
    
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('is disabled when loading', () => {
    render(<Button isLoading>Submit</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });
});
```

### Testing Server Actions

```typescript
// actions/posts.test.ts
import { createPost, deletePost } from './posts';
import { createClient } from '@/lib/supabase/server';

vi.mock('@/lib/supabase/server');

describe('createPost', () => {
  it('creates post with valid data', async () => {
    const mockSupabase = {
      auth: { getUser: vi.fn().mockResolvedValue({ data: { user: { id: '1' } } }) },
      from: vi.fn().mockReturnValue({
        insert: vi.fn().mockReturnValue({
          select: vi.fn().mockReturnValue({
            single: vi.fn().mockResolvedValue({ data: { id: '1', title: 'Test' }, error: null })
          })
        })
      })
    };
    vi.mocked(createClient).mockResolvedValue(mockSupabase);

    const formData = new FormData();
    formData.set('title', 'Test Post');

    const result = await createPost(formData);

    expect(result.success).toBe(true);
    expect(result.data.title).toBe('Test');
  });

  it('rejects unauthenticated users', async () => {
    const mockSupabase = {
      auth: { getUser: vi.fn().mockResolvedValue({ data: { user: null } }) }
    };
    vi.mocked(createClient).mockResolvedValue(mockSupabase);

    const formData = new FormData();
    formData.set('title', 'Test');

    const result = await createPost(formData);

    expect(result.success).toBe(false);
    expect(result.error).toContain('Unauthorized');
  });
});
```

### Testing Utilities

```typescript
// lib/utils.test.ts
import { cn, formatDate } from './utils';

describe('cn', () => {
  it('merges class names', () => {
    expect(cn('foo', 'bar')).toBe('foo bar');
  });

  it('handles conditional classes', () => {
    expect(cn('base', false && 'hidden', true && 'visible')).toBe('base visible');
  });

  it('merges tailwind classes correctly', () => {
    expect(cn('px-2 py-1', 'px-4')).toBe('py-1 px-4');
  });
});
```

## E2E Testing with Playwright

### Page Object Pattern

```typescript
// e2e/pages/login.page.ts
import { Page } from '@playwright/test';

export class LoginPage {
  constructor(private page: Page) {}

  async goto() {
    await this.page.goto('/login');
  }

  async login(email: string, password: string) {
    await this.page.fill('[name="email"]', email);
    await this.page.fill('[name="password"]', password);
    await this.page.click('button[type="submit"]');
  }

  async expectError(message: string) {
    await expect(this.page.getByText(message)).toBeVisible();
  }
}
```

### E2E Test Example

```typescript
// e2e/auth.spec.ts
import { test, expect } from '@playwright/test';
import { LoginPage } from './pages/login.page';

test.describe('Authentication', () => {
  test('user can login with valid credentials', async ({ page }) => {
    const loginPage = new LoginPage(page);
    
    await loginPage.goto();
    await loginPage.login('test@example.com', 'password123');
    
    await expect(page).toHaveURL('/dashboard');
    await expect(page.getByText('Welcome')).toBeVisible();
  });

  test('shows error with invalid credentials', async ({ page }) => {
    const loginPage = new LoginPage(page);
    
    await loginPage.goto();
    await loginPage.login('test@example.com', 'wrongpassword');
    
    await loginPage.expectError('Invalid credentials');
    await expect(page).toHaveURL('/login');
  });
});
```

## Test Organization

```
├── app/
│   └── posts/
│       ├── page.tsx
│       └── page.test.tsx        # Colocated unit tests
├── components/
│   └── button/
│       ├── button.tsx
│       └── button.test.tsx
├── lib/
│   └── utils.test.ts
├── actions/
│   └── posts.test.ts
├── e2e/                          # E2E tests separate
│   ├── pages/                    # Page objects
│   ├── auth.spec.ts
│   └── posts.spec.ts
└── vitest.config.ts
```

## What to Test

### Must Test
- Auth flows (login, logout, protected routes)
- Data mutations (create, update, delete)
- Critical business logic
- Edge cases and error states

### Should Test
- Component rendering with different props
- Form validation
- API response handling

### Don't Over-Test
- Third-party libraries
- Simple presentational components
- Framework behavior (Next.js routing)

## Test Scripts

```json
{
  "scripts": {
    "test": "vitest",
    "test:watch": "vitest --watch",
    "test:coverage": "vitest --coverage",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui"
  }
}
```

## CI Integration

Tests should run on every PR:

```yaml
# In .github/workflows/ci.yml
- name: Run unit tests
  run: npm run test -- --run

- name: Run E2E tests
  run: npm run test:e2e
```
